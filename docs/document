"""
ГЛАВНОЕ МЕНЮ КОНСОЛЬНОГО ПРИЛОЖЕНИЯ
====================================

Проект: "Восходящее проектирование и реализация алгоритмов"

Описание:
----------
Консольное приложение с текстовым интерфейсом, реализующее 3 алгоритма:
1. Сумма массивов с разной сортировкой
2. Поворот матрицы на 90 градусов
3. Поиск общих чисел с учетом перевернутых версий

Архитектура:
------------
Приложение использует принцип восходящего проектирования:
- utils/      - базовые модули (Задание 1)
- algorithms/ - реализация алгоритмов (Задание 2)
- main.py     - единый интерфейс (финальная сборка)

Особенности:
------------
• Строгий порядок операций: данные → выполнение → вывод
• Проверка корректности ввода
• Сброс результатов при вводе новых данных
• Разделение интерфейса и логики
"""

import sys
import os

# Добавление пути для корректного импорта модулей
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

# Импорт функций из алгоритмов
from algorithms.algorithm1 import sum_arrays_special
from algorithms.algorithm3 import rotate_clockwise, rotate_counterclockwise
from algorithms.algorithm8 import find_common_numbers

# Импорт функций ввода/вывода
from utils.input_operations import (
    manual_input_array,
    generate_random_array,
    generate_random_matrix
)


class ApplicationState:
    """
    Класс для хранения состояния приложения.

    Отвечает за управление данными и контролирует правильный порядок операций.
    Реализует требование: "При вводе новых данных результаты сбрасываются".

    Атрибуты:
    ---------
    current_task : int or None
        Номер текущего задания (1, 3, 8) или None если задание не выбрано
    data : any
        Введенные пользователем данные (зависит от задания)
    result : any
        Результат выполнения алгоритма
    data_entered : bool
        Флаг, указывающий что данные введены
    algorithm_executed : bool
        Флаг, указывающий что алгоритм выполнен

    Методы:
    -------
    reset_for_new_data()
        Сбрасывает результаты при вводе новых данных
    """

    def __init__(self):
        """Инициализация состояния приложения с пустыми значениями."""
        self.current_task = None      # 1, 3 или 8
        self.data = None              # Введенные данные
        self.result = None            # Результат выполнения
        self.data_entered = False     # Данные введены?
        self.algorithm_executed = False  # Алгоритм выполнен?

    def reset_for_new_data(self):
        """
        Сброс состояния при вводе новых данных.

        Реализует требование: "При вводе новых данных результаты
        выполнения алгоритма 'сбрасываются'".

        Сбрасывает:
        - result (результат)
        - algorithm_executed (флаг выполнения)
        """
        self.result = None
        self.algorithm_executed = False


def display_main_menu():
    """
    Отображение главного меню приложения.

    Меню соответствует требованиям задания:
    1. Выбор задания
    2. Ввод исходных данных
    3. Выполнение алгоритма
    4. Вывод результата
    5. Завершение работы

    Выводит:
    --------
    Отформатированное меню с доступными опциями
    """
    print("\n" + "="*60)
    print("ГЛАВНОЕ МЕНЮ КОНСОЛЬНОГО ПРИЛОЖЕНИЯ")
    print("="*60)
    print("1. Выбор задания (1, 3 или 8)")
    print("2. Ввод исходных данных (ручной/автоматический)")
    print("3. Выполнение алгоритма")
    print("4. Вывод результата")
    print("5. Завершение работы")
    print("="*60)


def select_task(state):
    """
    Пункт меню 1: Выбор задания для выполнения.

    Параметры:
    ----------
    state : ApplicationState
        Текущее состояние приложения

    Действия:
    ---------
    1. Отображает доступные задания
    2. Запрашивает выбор у пользователя
    3. Устанавливает current_task в состоянии
    4. Сбрасывает данные при изменении задания
    """
    print("\n--- ВЫБОР ЗАДАНИЯ ---")
    print("Доступные алгоритмы:")
    print("1. Сумма массивов с разной сортировкой")
    print("   - Два массива → разная сортировка → особая сумма")
    print("3. Поворот матрицы на 90 градусов")
    print("   - Матрица N×M → поворот по/против часовой")
    print("8. Поиск общих чисел с перевернутыми версиями")
    print("   - Два массива → поиск совпадений и перевернутых чисел")

    try:
        choice = int(input("\nВыберите номер задания (1, 3 или 8): "))

        if choice in [1, 3, 8]:
            state.current_task = choice
            state.reset_for_new_data()  # Сброс при новом выборе
            print(f"✓ Выбрано задание {choice}")
            print("Теперь перейдите к вводу данных (пункт 2)")
        else:
            print("✗ Ошибка: доступны только задания 1, 3, 8")

    except ValueError:
        print("✗ Ошибка: введите число (1, 3 или 8)!")


def input_data(state):
    """
    Пункт меню 2: Ввод исходных данных.

    Реализует требования:
    - Ввод данных вручную
    - Генерация случайных данных
    - Проверка корректности ввода

    Параметры:
    ----------
    state : ApplicationState
        Текущее состояние приложения

    Ограничения:
    ------------
    - Нельзя ввести данные без выбора задания
    - При вводе новых данных сбрасываются старые результаты
    """
    # Проверка: задание должно быть выбрано
    if state.current_task is None:
        print("✗ Ошибка: сначала выберите задание (пункт 1)!")
        return

    print(f"\n--- ВВОД ДАННЫХ ДЛЯ ЗАДАНИЯ {state.current_task} ---")
    print("Доступные способы ввода:")
    print("1. Ввести данные вручную")
    print("2. Сгенерировать случайные данные")

    try:
        choice = int(input("Ваш выбор (1 или 2): "))

        if choice not in [1, 2]:
            print("✗ Ошибка: выберите 1 или 2")
            return

        # ОБРАБОТКА ЗАДАНИЯ 1: Два массива чисел
        if state.current_task == 1:
            if choice == 1:  # Ручной ввод
                print("\n[Ручной ввод двух массивов]")
                print("Требование: массивы должны быть одинакового размера")

                size = int(input("Размер массивов: "))
                if size <= 0:
                    print("✗ Ошибка: размер должен быть положительным")
                    return

                print("\nПервый массив:")
                arr1 = manual_input_array(f"Введите {size} чисел через пробел: ")
                # Корректировка размера если введено неверное количество
                arr1 = _adjust_array_size(arr1, size)

                print("\nВторой массив:")
                arr2 = manual_input_array(f"Введите {size} чисел через пробел: ")
                arr2 = _adjust_array_size(arr2, size)

                state.data = (arr1, arr2)
                print(f"✓ Массивы сохранены: {arr1}, {arr2}")

            else:  # Генерация
                print("\n[Генерация случайных массивов]")
                size = int(input("Размер массивов: "))
                min_val = int(input("Минимальное значение: "))
                max_val = int(input("Максимальное значение: "))

                if size <= 0:
                    print("✗ Ошибка: размер должен быть положительным")
                    return
                if min_val > max_val:
                    print("⚠ Минимальное значение больше максимального, меняю местами")
                    min_val, max_val = max_val, min_val

                arr1 = generate_random_array(size, min_val, max_val)
                arr2 = generate_random_array(size, min_val, max_val)
                state.data = (arr1, arr2)

                print(f"✓ Сгенерированы массивы:")
                print(f"  Массив 1: {arr1}")
                print(f"  Массив 2: {arr2}")

        # ОБРАБОТКА ЗАДАНИЯ 3: Матрица
        elif state.current_task == 3:
            if choice == 1:  # Ручной ввод
                print("\n[Ручной ввод матрицы]")
                rows = int(input("Количество строк: "))
                cols = int(input("Количество столбцов: "))

                if rows <= 0 or cols <= 0:
                    print("✗ Ошибка: размеры должны быть положительными")
                    return

                print(f"\nВведите матрицу {rows}x{cols} (по строкам):")
                matrix = []
                for i in range(rows):
                    while True:
                        try:
                            row_input = input(f"Строка {i+1}: ")
                            row = [float(x) for x in row_input.split()]

                            if len(row) != cols:
                                print(f"⚠ Ожидалось {cols} чисел, получено {len(row)}. Корректирую...")
                                row = _adjust_array_size(row, cols)

                            matrix.append(row)
                            break
                        except ValueError:
                            print("✗ Ошибка: вводите только числа!")

                state.data = matrix
                print(f"✓ Матрица сохранена ({rows}x{cols})")

            else:  # Генерация
                print("\n[Генерация случайной матрицы]")
                rows = int(input("Количество строк: "))
                cols = int(input("Количество столбцов: "))
                min_val = int(input("Минимальное значение: "))
                max_val = int(input("Максимальное значение: "))

                if rows <= 0 or cols <= 0:
                    print("✗ Ошибка: размеры должны быть положительными")
                    return

                matrix = generate_random_matrix(rows, cols, min_val, max_val)
                state.data = matrix

                print(f"✓ Сгенерирована матрица {rows}x{cols}:")
                for i, row in enumerate(matrix):
                    print(f"  Строка {i+1}: {row}")

        # ОБРАБОТКА ЗАДАНИЯ 8: Два массива для поиска общих чисел
        elif state.current_task == 8:
            if choice == 1:  # Ручной ввод
                print("\n[Ручной ввод двух массивов]")
                print("Для задания 8 рекомендуются целые положительные числа")

                size = int(input("Размер массивов: "))
                if size <= 0:
                    print("✗ Ошибка: размер должен быть положительным")
                    return

                print("\nПервый массив:")
                arr1 = manual_input_array(f"Введите {size} чисел через пробел: ")
                arr1 = _adjust_array_size(arr1, size)

                print("\nВторой массив:")
                arr2 = manual_input_array(f"Введите {size} чисел через пробел: ")
                arr2 = _adjust_array_size(arr2, size)

                state.data = (arr1, arr2)
                print(f"✓ Массивы сохранены")

            else:  # Генерация
                print("\n[Генерация массивов для поиска общих чисел]")
                print("Рекомендация: используйте числа ≥10 для работы с перевернутыми версиями")

                size = int(input("Размер массивов: "))
                min_val = int(input("Минимальное значение (рекомендуется ≥10): "))
                max_val = int(input("Максимальное значение: "))

                if size <= 0:
                    print("✗ Ошибка: размер должен быть положительным")
                    return

                arr1 = generate_random_array(size, min_val, max_val)
                arr2 = generate_random_array(size, min_val, max_val)
                state.data = (arr1, arr2)

                print(f"✓ Сгенерированы массивы:")
                print(f"  Массив 1: {arr1}")
                print(f"  Массив 2: {arr2}")

        # Обновление состояния
        state.data_entered = True
        state.reset_for_new_data()  # Сброс старых результатов
        print("\n✓ Данные успешно сохранены!")
        print("Теперь можно выполнить алгоритм (пункт 3)")

    except ValueError as e:
        print(f"✗ Ошибка ввода: {e}")
    except Exception as e:
        print(f"✗ Неожиданная ошибка: {e}")


def execute_algorithm(state):
    """
    Пункт меню 3: Выполнение алгоритма.

    Реализует требования:
    - Алгоритм не может быть выполнен без введенных данных
    - Выполнение соответствующего выбранному заданию алгоритма

    Параметры:
    ----------
    state : ApplicationState
        Текущее состояние приложения
    """
    # Проверка 1: задание должно быть выбрано
    if state.current_task is None:
        print("✗ Ошибка: сначала выберите задание (пункт 1)!")
        return

    # Проверка 2: данные должны быть введены
    if not state.data_entered:
        print("✗ Ошибка: сначала введите данные (пункт 2)!")
        return

    print(f"\n--- ВЫПОЛНЕНИЕ АЛГОРИТМА {state.current_task} ---")

    try:
        # ЗАДАНИЕ 1: Сумма массивов с особой логикой
        if state.current_task == 1:
            print("Алгоритм 1: Сумма массивов с разной сортировкой")
            print("Правила:")
            print("1. Первый массив сортируется по убыванию")
            print("2. Второй массив сортируется по возрастанию")
            print("3. Если числа равны, сумма = 0")
            print("4. Итоговый массив сортируется по возрастанию")

            arr1, arr2 = state.data
            state.result = sum_arrays_special(arr1, arr2)
            print("✓ Алгоритм выполнен успешно!")

        # ЗАДАНИЕ 3: Поворот матрицы
        elif state.current_task == 3:
            print("Алгоритм 3: Поворот матрицы на 90 градусов")

            matrix = state.data
            print(f"Размер матрицы: {len(matrix)}x{len(matrix[0])}")

            print("\nВыберите направление поворота:")
            print("1. По часовой стрелке")
            print("2. Против часовой стрелки")

            try:
                direction = int(input("Ваш выбор (1 или 2): "))

                if direction == 1:
                    state.result = rotate_clockwise(matrix)
                    print("✓ Матрица повернута по часовой стрелке")
                elif direction == 2:
                    state.result = rotate_counterclockwise(matrix)
                    print("✓ Матрица повернута против часовой стрелки")
                else:
                    print("✗ Ошибка: выберите 1 или 2")
                    return
            except ValueError:
                print("✗ Ошибка: введите число!")
                return

        # ЗАДАНИЕ 8: Поиск общих чисел
        elif state.current_task == 8:
            print("Алгоритм 8: Поиск общих чисел")
            print("Правила поиска:")
            print("1. Прямое совпадение чисел")
            print("2. Совпадение с перевернутой версией числа")
            print("   (например, 123 и 321 считаются общими)")

            arr1, arr2 = state.data
            state.result = find_common_numbers(arr1, arr2)
            print("✓ Поиск общих чисел выполнен!")

        # Установка флага выполнения
        state.algorithm_executed = True
        print("\n✓ Алгоритм успешно выполнен!")
        print("Теперь можно вывести результат (пункт 4)")

    except ValueError as e:
        print(f"✗ Ошибка в данных: {e}")
    except Exception as e:
        print(f"✗ Ошибка выполнения алгоритма: {e}")


def display_result(state):
    """
    Пункт меню 4: Вывод результата выполнения алгоритма.

    Реализует требования:
    - Результат не может быть выведен без выполнения алгоритма
    - Форматированный вывод в зависимости от типа результата

    Параметры:
    ----------
    state : ApplicationState
        Текущее состояние приложения
    """
    # Проверка: алгоритм должен быть выполнен
    if not state.algorithm_executed:
        print("✗ Ошибка: сначала выполните алгоритм (пункт 3)!")
        return

    print(f"\n{'='*60}")
    print(f"РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ ЗАДАНИЯ {state.current_task}")
    print('='*60)

    # ВЫВОД ДЛЯ ЗАДАНИЯ 1
    if state.current_task == 1:
        arr1, arr2 = state.data

        print("\nИСХОДНЫЕ ДАННЫЕ:")
        print(f"Массив 1 ({len(arr1)} элементов): {arr1}")
        print(f"Массив 2 ({len(arr2)} элементов): {arr2}")

        print("\nПРОЦЕСС ВЫПОЛНЕНИЯ:")
        print("1. Первый массив отсортирован по убыванию")
        print("2. Второй массив отсортирован по возрастанию")
        print("3. Поэлементная сумма с особым правилом (равные = 0)")
        print("4. Итоговый массив отсортирован по возрастанию")

        print("\nРЕЗУЛЬТАТ:")
        print(f"Массив ({len(state.result)} элементов): {state.result}")

        # Дополнительная информация
        print("\nАНАЛИЗ:")
        zero_count = state.result.count(0)
        print(f"• Количество нулей в результате: {zero_count}")
        print(f"• Минимальное значение: {min(state.result)}")
        print(f"• Максимальное значение: {max(state.result)}")

    # ВЫВОД ДЛЯ ЗАДАНИЯ 3
    elif state.current_task == 3:
        print("\nИСХОДНАЯ МАТРИЦА:")
        print(f"Размер: {len(state.data)} строк × {len(state.data[0])} столбцов")
        for i, row in enumerate(state.data):
            print(f"  Строка {i+1}: {row}")

        print("\nРЕЗУЛЬТАТ (повернутая матрица):")
        print(f"Размер: {len(state.result)} строк × {len(state.result[0])} столбцов")
        for i, row in enumerate(state.result):
            print(f"  Строка {i+1}: {row}")

        # Дополнительная информация
        print("\nАНАЛИЗ:")
        print(f"• Исходная матрица: {len(state.data)}×{len(state.data[0])}")
        print(f"• Повернутая матрица: {len(state.result)}×{len(state.result[0])}")
        print(f"• Количество элементов: {len(state.data)*len(state.data[0])}")

    # ВЫВОД ДЛЯ ЗАДАНИЯ 8
    elif state.current_task == 8:
        arr1, arr2 = state.data

        print("\nИСХОДНЫЕ ДАННЫЕ:")
        print(f"Массив 1 ({len(arr1)} элементов): {arr1}")
        print(f"Массив 2 ({len(arr2)} элементов): {arr2}")

        print("\nРЕЗУЛЬТАТ ПОИСКА:")
        if state.result:
            print(f"Найдено общих чисел: {len(state.result)}")
            print(f"Общие числа: {state.result}")

            # Анализ типов совпадений
            print("\nАНАЛИЗ СОВПАДЕНИЙ:")
            direct_matches = []
            reversed_matches = []

            for num in state.result:
                if num in arr1 and num in arr2:
                    direct_matches.append(num)
                else:
                    # Поиск перевернутой версии
                    for check_num in arr1:
                        if isinstance(check_num, int) and check_num >= 0:
                            reversed_num = int(str(check_num)[::-1])
                            if reversed_num in arr2 and check_num == num:
                                reversed_matches.append((check_num, reversed_num))

            if direct_matches:
                print(f"• Прямые совпадения ({len(direct_matches)}): {direct_matches}")
            if reversed_matches:
                print(f"• Совпадения с перевернутыми числами ({len(reversed_matches)}):")
                for original, reversed_num in reversed_matches:
                    print(f"  {original} ↔ {reversed_num}")
        else:
            print("Общих чисел не найдено")

        print(f"\nСТАТИСТИКА:")
        print(f"• Всего чисел в массивах: {len(arr1) + len(arr2)}")
        print(f"• Найдено общих: {len(state.result)}")
        print(f"• Процент общих: {len(state.result)/len(arr1)*100:.1f}%")

    print('='*60)


def _adjust_array_size(arr, target_size):
    """
    Вспомогательная функция для корректировки размера массива.

    Параметры:
    ----------
    arr : list
        Исходный массив
    target_size : int
        Целевой размер

    Возвращает:
    -----------
    list
        Массив скорректированного размера

    Действия:
    ---------
    - Если массив короче: дополняет нулями
    - Если массив длиннее: обрезает
    """
    if len(arr) < target_size:
        return arr + [0] * (target_size - len(arr))
    elif len(arr) > target_size:
        return arr[:target_size]
    return arr


def main():
    """
    Главная функция приложения.

    Управляет основным циклом программы и обработкой пользовательского ввода.
    Реализует паттерн "Конечный автомат" для управления состоянием приложения.
    """
    print("\n" + "="*60)
    print("ПРОЕКТ: ВОСХОДЯЩЕЕ ПРОЕКТИРОВАНИЕ И РЕАЛИЗАЦИЯ АЛГОРИТМОВ")
    print("="*60)
    print("Описание:")
    print("• Задание 1: Восходящее проектирование (ветки array-operations,")
    print("             data-validation, matrix-operations)")
    print("• Задание 2: Консольное приложение с 3 алгоритмами")
    print("="*60)

    # Инициализация состояния приложения
    state = ApplicationState()

    # Главный цикл приложения
    while True:
        display_main_menu()

        try:
            choice = input("\nВыберите пункт меню (1-5): ").strip()

            # Обработка выбора пользователя
            if choice == "1":
                select_task(state)
            elif choice == "2":
                input_data(state)
            elif choice == "3":
                execute_algorithm(state)
            elif choice == "4":
                display_result(state)
            elif choice == "5":
                # Завершение работы
                print("\n" + "="*60)
                print("ЗАВЕРШЕНИЕ РАБОТЫ ПРИЛОЖЕНИЯ")
                print("="*60)
                print("Спасибо за использование программы!")
                print("Автор: [Ваше имя]")
                print("Дата разработки: [Текущая дата]")
                print("="*60)
                break
            elif choice.lower() == "help":
                # Секретная команда помощи
                print("\n[СПРАВКА]")
                print("Порядок работы с программой:")
                print("1. Выберите задание (1, 3 или 8)")
                print("2. Введите данные (вручную или сгенерируйте)")
                print("3. Выполните алгоритм")
                print("4. Просмотрите результат")
                print("\nОграничения:")
                print("• Нельзя выполнить алгоритм без данных")
                print("• Нельзя вывести результат без выполнения")
                print("• Новые данные сбрасывают результаты")
            else:
                print("✗ Ошибка: введите число от 1 до 5")

        except KeyboardInterrupt:
            # Обработка прерывания (Ctrl+C)
            print("\n\n⚠ Программа прервана пользователем")
            confirm = input("Завершить программу? (да/нет): ").lower()
            if confirm in ['да', 'д', 'yes', 'y']:
                print("Завершение работы...")
                break
        except Exception as e:
            # Обработка неожиданных ошибок
            print(f"\n✗ Критическая ошибка: {e}")
            print("Пожалуйста, сообщите об этой ошибке разработчику")

    # Финальное сообщение
    print("\nДо свидания!")


if __name__ == "__main__":
    """
    Точка входа в программу.

    Запускает главную функцию при прямом выполнении файла.
    Позволяет также импортировать функции без запуска меню.
    """
    main()